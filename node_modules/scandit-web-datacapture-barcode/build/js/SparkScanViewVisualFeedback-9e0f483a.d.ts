import { LocationSelectionJSON, JSONType, FrameData, DataCaptureMode, DataCaptureContext, DataCaptureModeJSON, Color, Feedback, ColorJSON, FeedbackJSON, TorchState, Point } from 'scandit-web-datacapture-core';
import { Serializable } from 'scandit-web-datacapture-core/build/js/private/Serializable';
import { BarcodeJSON, Barcode, Symbology } from './Barcode.js';
import { ScanIntention } from './ScanIntention.js';
import { SymbologySettingsJSON, SymbologySettings } from './SymbologySettings.js';
import { S as SparkScanViewHandMode } from './SparkScanViewHandMode-b5686d15.js';

interface SparkScanSessionJSON {
    newlyRecognizedBarcodes: BarcodeJSON[];
    frameSequenceId: number;
}
declare class SparkScanSession {
    newlyRecognizedBarcodes: Barcode[];
    frameSequenceID: number;
    private static fromJSON;
}

interface SparkScanSettingsJSON {
    codeDuplicateFilter: number;
    locationSelection: LocationSelectionJSON;
    symbologies: Record<Symbology, SymbologySettingsJSON>;
    properties: Record<string, JSONType>;
    scanIntention: ScanIntention | null;
}
declare class SparkScanSettings implements Serializable<SparkScanSettingsJSON> {
    codeDuplicateFilter: number;
    scanIntention?: ScanIntention;
    private locationSelection;
    private properties;
    private symbologies;
    constructor();
    get enabledSymbologies(): Symbology[];
    settingsForSymbology(symbology: Symbology): SymbologySettings;
    setProperty(name: string, value: any): void;
    getProperty(name: string): any;
    enableSymbologies(symbologies: Symbology[]): void;
    enableSymbology(symbology: Symbology, enabled: boolean): void;
    toJSONObject(): SparkScanSettingsJSON;
    private enableTargetModeHiddenProperties;
    private disableTargetModeHiddenProperties;
}

interface SparkScanListener {
    didScan?: (sparkScan: SparkScan, session: SparkScanSession, frameData: FrameData) => void;
    didUpdateSession?: (sparkScan: SparkScan, session: SparkScanSession) => void;
}
type SparkScanJSON = DataCaptureModeJSON<SparkScanSettingsJSON>;
declare class SparkScan implements DataCaptureMode, Serializable<SparkScanJSON> {
    private readonly type;
    private _isEnabled;
    private settings;
    private _context;
    private readonly listeners;
    private allowedRemainingWorkerMessages;
    private readonly workerMessageListener;
    private static get recommendedCameraSettings();
    get context(): DataCaptureContext | null;
    static forSettings(settings: SparkScanSettings): SparkScan;
    isEnabled(): boolean;
    setEnabled(enabled: boolean): Promise<void>;
    applySettings(settings: SparkScanSettings): Promise<void>;
    addListener(listener: SparkScanListener): void;
    removeListener(listener: SparkScanListener): void;
    toJSONObject(): SparkScanJSON;
    private attachedToContext;
    private detachedFromContext;
    private sendClearFrameDataRequest;
    private onDidScan;
    private onDidUpdateSession;
    private onWorkerMessage;
    private notifyContext;
}

declare enum SparkScanPreviewBehavior {
    Default = "default",
    Persistent = "persistent"
}

declare enum SparkScanScanningBehavior {
    Single = "single",
    Continuous = "continuous"
}

interface SparkScanScanningModeJSON {
    type: "default" | "target";
    scanningBehavior: SparkScanScanningBehavior;
    previewBehavior: SparkScanPreviewBehavior;
}
declare abstract class SparkScanScanningMode implements Serializable<SparkScanScanningModeJSON> {
    readonly scanningBehavior: SparkScanScanningBehavior;
    readonly previewBehavior: SparkScanPreviewBehavior;
    constructor(scanningBehavior: SparkScanScanningBehavior, previewBehavior: SparkScanPreviewBehavior);
    abstract toJSONObject(): SparkScanScanningModeJSON;
    protected abstract copyWith(scanningBehavior?: SparkScanScanningBehavior, previewBehavior?: SparkScanPreviewBehavior): SparkScanScanningMode;
    protected abstract changeMode(): SparkScanScanningMode;
}
declare class SparkScanScanningModeDefault extends SparkScanScanningMode {
    toJSONObject(): SparkScanScanningModeJSON;
    protected copyWith(scanningBehavior?: SparkScanScanningBehavior, previewBehavior?: SparkScanPreviewBehavior): SparkScanScanningMode;
    protected changeMode(): SparkScanScanningMode;
}
declare class SparkScanScanningModeTarget extends SparkScanScanningMode {
    toJSONObject(): SparkScanScanningModeJSON;
    protected copyWith(scanningBehavior?: SparkScanScanningBehavior, previewBehavior?: SparkScanPreviewBehavior): SparkScanScanningMode;
    protected changeMode(): SparkScanScanningMode;
}

interface SparkScanToastSettingsJSON {
    continuousModeDisabledMessage: string | null;
    continuousModeEnabledMessage: string | null;
    scanPausedMessage: string | null;
    toastBackgroundColor: string | null;
    toastEnabled: boolean;
    toastTextColor: string | null;
    torchDisabledMessage: string | null;
    torchEnabledMessage: string | null;
    zoomedInMessage: string | null;
    zoomedOutMessage: string | null;
}
declare class SparkScanToastSettings implements Serializable<SparkScanToastSettingsJSON> {
    continuousModeDisabledMessage: string | null;
    continuousModeEnabledMessage: string | null;
    scanPausedMessage: string | null;
    targetModeDisabledMessage: string | null;
    targetModeEnabledMessage: string | null;
    toastBackgroundColor: Color | null;
    toastEnabled: boolean;
    toastTextColor: Color | null;
    torchDisabledMessage: string | null;
    torchEnabledMessage: string | null;
    zoomedInMessage: string | null;
    zoomedOutMessage: string | null;
    toJSONObject(): SparkScanToastSettingsJSON;
}

interface SparkScanBarcodeErrorFeedbackJSON {
    type: "error";
    barcodeFeedback: {
        message: string;
        resumeCapturingDelay: number;
        visualFeedbackColor?: ColorJSON;
        feedback?: FeedbackJSON;
    };
}
interface SparkScanBarcodeSuccessFeedbackJSON {
    type: "success";
    barcodeFeedback: {
        visualFeedbackColor?: ColorJSON;
        feedback?: FeedbackJSON;
    };
}
type SparkScanBarcodeFeedbackJSON = SparkScanBarcodeErrorFeedbackJSON | SparkScanBarcodeSuccessFeedbackJSON;
declare abstract class SparkScanBarcodeFeedback {
    visualFeedbackColor: Color;
    feedback: Feedback;
    constructor(visualFeedbackColor: Color, feedback: Feedback);
    static defaultSuccessFeedback(): Feedback;
    static defaultErrorFeedback(): Feedback;
    static success(): SparkScanBarcodeSuccessFeedback;
    abstract toJSONObject(): SparkScanBarcodeFeedbackJSON;
}
declare class SparkScanBarcodeErrorFeedback extends SparkScanBarcodeFeedback {
    message: string;
    resumeCapturingDelay: number;
    visualFeedbackColor: Color;
    feedback: Feedback;
    constructor(message: string, resumeCapturingDelay: number, visualFeedbackColor?: Color, feedback?: Feedback);
    toJSONObject(): SparkScanBarcodeFeedbackJSON;
}
declare class SparkScanBarcodeSuccessFeedback extends SparkScanBarcodeFeedback {
    visualFeedbackColor: Color;
    feedback: Feedback;
    constructor(visualFeedbackColor?: Color, feedback?: Feedback);
    toJSONObject(): SparkScanBarcodeFeedbackJSON;
}

interface SparkScanFeedbackDelegate {
    getFeedbackForBarcode(barcode: Barcode): SparkScanBarcodeFeedback | null;
}

type SparkScanViewFeedback = SparkScanViewErrorFeedback | SparkScanViewSuccessFeedback;
interface SparkScanViewSuccessFeedbackJSON {
    type: string;
    visualFeedbackColor: ColorJSON | null;
}
declare class SparkScanViewSuccessFeedback implements Serializable<SparkScanViewSuccessFeedbackJSON> {
    readonly type: string;
    readonly visualFeedbackColor: Color | null;
    constructor(visualFeedbackColor: Color | null);
    toJSONObject(): SparkScanViewSuccessFeedbackJSON;
}
interface SparkScanViewErrorFeedbackJSON {
    type: string;
    message: string;
    resumeCapturingDelay: number;
    visualFeedbackColor: ColorJSON | null;
}
declare class SparkScanViewErrorFeedback implements Serializable<SparkScanViewErrorFeedbackJSON> {
    readonly type: string;
    readonly message: string;
    readonly resumeCapturingDelay: number;
    readonly visualFeedbackColor: Color | null;
    constructor(message: string, resumeCapturingDelay: number, visualFeedbackColor: Color | null);
    toJSONObject(): SparkScanViewErrorFeedbackJSON;
}

interface SparkScanViewSettingsJSON {
    defaultHandMode: SparkScanViewHandMode;
    defaultScanningMode: SparkScanScanningModeJSON;
    defaultTorchState: TorchState;
    hapticEnabled: boolean;
    holdToScanEnabled: boolean;
    inactiveStateTimeout: number;
    soundEnabled: boolean;
    toastSettings: SparkScanToastSettingsJSON;
    triggerButtonCollapseTimeout: number;
    visualFeedbackEnabled: boolean;
    zoomFactorIn: number;
    zoomFactorOut: number;
}
declare class SparkScanViewSettings implements Serializable<SparkScanViewSettingsJSON> {
    defaultHandMode: SparkScanViewHandMode;
    defaultScanningMode: SparkScanScanningMode;
    defaultTorchState: TorchState;
    hapticEnabled: boolean;
    holdToScanEnabled: boolean;
    inactiveStateTimeout: number;
    soundEnabled: boolean;
    toastSettings: SparkScanToastSettings;
    triggerButtonCollapseTimeout: number;
    visualFeedbackEnabled: boolean;
    zoomFactorIn: number;
    zoomFactorOut: number;
    constructor();
    toJSONObject(): SparkScanViewSettingsJSON;
}

declare const zoomFactorAttribute = "zoom-factor";
declare const handModeAttribute = "hand-mode";
declare const handModeButtonVisibleAttribute = "hand-mode-button-visible";
declare const hapticEnabledAttribute = "haptic-enabled";
declare const hapticModeButtonVisibleAttribute = "haptic-mode-button-visible";
declare const leftHandModeAttribute = "left-hand-mode";
declare const scanningBehaviorAttribute = "scanning-behavior";
declare const scanningBehaviorButtonVisibleAttribute = "scanning-behavior-button-visible";
declare const soundEnabledAttribute = "sound-enabled";
declare const soundModeButtonVisibleAttribute = "sound-mode-button-visible";
declare const targetModeButtonVisibleAttribute = "target-mode-button-visible";
declare const targetModeEnabledAttribute = "target-mode-enabled";
declare const torchButtonVisibleAttribute = "torch-button-visible";
declare const torchEnabledAttribute = "torch-enabled";
declare const inlineStyleAttribute = "inline-style";
declare const zoomSwitchControlVisibleAttribute = "zoom-switch-control-visible";
declare const previewSizeControlVisibleAttribute = "preview-size-control-visible";

declare const sparkScanViewCollapsedTriggerButtonTag = "spark-scan-view-collapsed-trigger-button";
declare const sparkScanViewExpandedTriggerButtonTag = "spark-scan-view-expanded-trigger-button";
declare const sparkScanViewIconTag = "spark-scan-view-icon";
declare const sparkScanViewMiniPreviewTag = "spark-scan-view-mini-preview";
declare const sparkScanViewSidebarTag = "spark-scan-view-sidebar";
declare const sparkScanViewTag = "spark-scan-view";
declare const sparkScanViewToastTag = "spark-scan-view-toast";
declare const sparkScanViewTriggerButtonTag = "spark-scan-view-trigger-button";
declare const sparkScanViewVisualFeedbackTag = "spark-scan-view-visual-feedback";

declare class SparkScanView extends HTMLElement {
    targetModeButtonVisible: boolean;
    scanningBehaviorButtonVisible: boolean;
    torchButtonVisible: boolean;
    soundModeButtonVisible: boolean;
    hapticModeButtonVisible: boolean;
    handModeButtonVisible: boolean;
    zoomSwitchControlVisible: boolean;
    previewSizeControlVisible: boolean;
    startCapturingText?: string;
    scanningCapturingText?: string;
    resumeCapturingText?: string;
    stopCapturingText?: string;
    captureButtonBackgroundColor?: Color;
    captureButtonActiveBackgroundColor?: Color;
    captureButtonTintColor?: Color;
    toolbarBackgroundColor?: Color;
    toolbarIconActiveTintColor?: Color;
    toolbarIconInactiveTintColor?: Color;
    didChangeScanningMode?: (scanningMode: SparkScanScanningMode) => void;
    feedbackDelegate: SparkScanFeedbackDelegate;
    private presenter;
    private settings;
    private miniPreview;
    private triggerButton;
    private visualFeedback;
    private styleElement;
    private miniPreviewTimeout;
    private triggerButtonRepositioningTimeout;
    private triggerButtonTranslateY;
    private triggerButtonTranslateYOffset;
    private gestureManager?;
    private orientationManager;
    private miniPreviewButtonTapListener;
    private miniPreviewSwipeUpListener;
    private miniPreviewSwipeDownListener;
    private triggerButtonTapListener;
    private triggerButtonHoldStartListener;
    private triggerButtonHoldEndListener;
    private triggerButtonVerticalSwipeStartListener;
    private triggerButtonVerticalSwipeListener;
    private triggerButtonVerticalSwipeEndListener;
    private triggerButtonSwipeLeftListener;
    private triggerButtonSwipeRightListener;
    private sidebarButtonTapListener;
    private clickOutsideListener;
    private visibilityChangeListener;
    private orientationChangeListener;
    private swipingVertically;
    private get [handModeAttribute]();
    private set [handModeAttribute](value);
    private get _startCapturingText();
    private get _resumeCapturingText();
    private get _scanningCapturingText();
    private get _stopCapturingText();
    private get _targetModeEnabledMessage();
    private get _targetModeDisabledMessage();
    private get _continuousModeEnabledMessage();
    private get _continuousModeDisabledMessage();
    private get _scanPausedMessage();
    private get _torchEnabledMessage();
    private get _torchDisabledMessage();
    private get _zoomedInMessage();
    private get _zoomedOutMessage();
    static forElement(element: Element, context: DataCaptureContext, sparkScan: SparkScan, sparkScanViewSettings?: SparkScanViewSettings): SparkScanView;
    private static create;
    prepareScanning(): Promise<void>;
    startScanning(): Promise<void>;
    pauseScanning(): Promise<void>;
    stopScanning(): Promise<void>;
    showToast(message: string): void;
    emitFeedback(feedback: SparkScanViewFeedback): Promise<void>;
    private mount;
    private unmount;
    private connectedCallback;
    private disconnectedCallback;
    private setTorchAvailable;
    private switchToIdleState;
    private switchToActiveState;
    private switchToInactiveState;
    private switchToErrorState;
    private setTriggerButtonTranslateY;
    private bounceTriggerButtonTranslateY;
    private setTranslateYForOrientation;
    private onMiniPreviewButtonTap;
    private onMiniPreviewSwipeUp;
    private onMiniPreviewSwipeDown;
    private onTriggerButtonTap;
    private onTriggerButtonHoldStart;
    private onTriggerButtonHoldEnd;
    private onTriggerButtonVerticalSwipeStart;
    private onTriggerButtonVerticalSwipe;
    private onTriggerButtonVerticalSwipeEnd;
    private onTriggerButtonSwipeLeft;
    private onTriggerButtonSwipeRight;
    private onSidebarButtonTap;
    private onClickOutside;
    private onVisibilityChange;
    private onTargetModeButtonTap;
    private onScanningBehaviorButtonTap;
    private onTorchButtonTap;
    private onSoundModeButtonTap;
    private onHapticModeButtonTap;
    private onHandModeButtonTap;
    private onMiniPreviewTimeoutFinished;
    private onTriggerButtonRepositioningTimeoutFinished;
    private onOrientationChange;
    private targetModeButtonTapped;
    private scanningBehaviorButtonTapped;
    private torchButtonTapped;
    private soundModeButtonTapped;
    private hapticModeButtonTapped;
    private handModeButtonTapped;
    private miniPreviewSwipedUp;
    private miniPreviewSwipedDown;
    private isTriggerButtonOverlappingMiniPreview;
    private isTriggerButtonAboveScreenStart;
    private isTriggerButtonBelowScreenEnd;
    private positionTriggerButtonBasedOnAvailableSpace;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewTag]: SparkScanView;
    }
}

declare const collapsedTriggerButtonTapEvent = "collapsedtriggerbuttontap";
declare const expandedTriggerButtonTapEvent = "expandedtriggerbuttontap";
declare const sidebarButtonTapEvent = "sidebarbuttontap";
declare const triggerButtonGestureManagerHoldEndEvent = "holdend";
declare const triggerButtonGestureManagerHoldStartEvent = "holdstart";
declare const triggerButtonGestureManagerTapEvent = "tap";
declare const orientationChangeEvent = "orientationchange";
declare const miniPreviewButtonTapEvent = "minipreviewbuttontap";
declare const miniPreviewSwipeUpEvent = "minipreviewswipeup";
declare const miniPreviewSwipeDownEvent = "minipreviewswipedown";

declare class SparkScanViewCollapsedTriggerButton extends HTMLElement {
    private pointerDownListener;
    static create(): SparkScanViewCollapsedTriggerButton;
    private render;
    private onPointerDown;
    private connectedCallback;
    private disconnectedCallback;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewCollapsedTriggerButtonTag]: SparkScanViewCollapsedTriggerButton;
    }
    interface HTMLElementEventMap {
        [collapsedTriggerButtonTapEvent]: CustomEvent<{
            clientX: number;
            clientY: number;
        }>;
    }
}

type SparkScanViewSidebarButtonType = "handModeButton" | "hapticModeButton" | "scanningBehaviorButton" | "soundModeButton" | "targetModeButton" | "torchButton";
declare class SparkScanViewSidebar extends HTMLElement {
    private static readonly observedAttributes;
    private targetModeButton?;
    private targetModeButtonIcon?;
    private scanningBehaviorButton?;
    private scanningBehaviorButtonIcon?;
    private torchButton?;
    private torchButtonIcon?;
    private soundModeButton?;
    private soundModeButtonIcon?;
    private hapticModeButton?;
    private hapticModeButtonIcon?;
    private handModeButton?;
    private handModeButtonIcon?;
    private targetModeButtonTapListener;
    private scanningBehaviorButtonTapListener;
    private torchButtonTapListener;
    private soundModeButtonTapListener;
    private hapticModeButtonTapListener;
    private handModeButtonTapListener;
    private computedStyle;
    get [targetModeButtonVisibleAttribute](): boolean;
    set [targetModeButtonVisibleAttribute](targetModeButtonVisible: boolean);
    get [scanningBehaviorButtonVisibleAttribute](): boolean;
    set [scanningBehaviorButtonVisibleAttribute](scanningBehaviorButtonVisible: boolean);
    get [torchButtonVisibleAttribute](): boolean;
    set [torchButtonVisibleAttribute](torchButtonVisible: boolean);
    get [soundModeButtonVisibleAttribute](): boolean;
    set [soundModeButtonVisibleAttribute](soundModeButtonVisible: boolean);
    get [hapticModeButtonVisibleAttribute](): boolean;
    set [hapticModeButtonVisibleAttribute](hapticModeButtonVisible: boolean);
    get [handModeButtonVisibleAttribute](): boolean;
    set [handModeButtonVisibleAttribute](handModeButtonVisible: boolean);
    get [targetModeEnabledAttribute](): boolean;
    set [targetModeEnabledAttribute](targetModeEnabled: boolean);
    get [scanningBehaviorAttribute](): SparkScanScanningBehavior;
    set [scanningBehaviorAttribute](scanningBehavior: SparkScanScanningBehavior);
    get [torchEnabledAttribute](): boolean;
    set [torchEnabledAttribute](torchEnabled: boolean);
    get [soundEnabledAttribute](): boolean;
    set [soundEnabledAttribute](soundEnabled: boolean);
    get [hapticEnabledAttribute](): boolean;
    set [hapticEnabledAttribute](hapticEnabled: boolean);
    get [handModeAttribute](): SparkScanViewHandMode;
    set [handModeAttribute](handMode: SparkScanViewHandMode);
    get allButtonsHidden(): boolean;
    get visibleButtonCount(): number;
    static create(): SparkScanViewSidebar;
    private render;
    private connectedCallback;
    private disconnectedCallback;
    private attributeChangedCallback;
    private onTargetModeButtonTap;
    private onScanningBehaviorButtonTap;
    private onTorchButtonTap;
    private onSoundModeButtonTap;
    private onHapticModeButtonTap;
    private onHandModeButtonTap;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewSidebarTag]: SparkScanViewSidebar;
    }
    interface HTMLElementEventMap {
        [sidebarButtonTapEvent]: CustomEvent<{
            tapped: SparkScanViewSidebarButtonType;
            enabled: boolean;
        }>;
    }
}

declare class SparkScanViewExpandedTriggerButton extends HTMLElement {
    private static readonly observedAttributes;
    sidebar?: SparkScanViewSidebar | null;
    private messageElement?;
    private fadeOutAnimation?;
    private fadeInAnimation?;
    private fadeOutAnimationFinishListener;
    private pointerDownListener;
    get message(): string;
    set message(message: string);
    get active(): boolean;
    set active(active: boolean);
    static create(): SparkScanViewExpandedTriggerButton;
    private render;
    private onFadeOutAnimationFinish;
    private onPointerDown;
    private connectedCallback;
    private disconnectedCallback;
    private attributeChangedCallback;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewExpandedTriggerButtonTag]: SparkScanViewExpandedTriggerButton;
    }
    interface HTMLElementEventMap {
        [expandedTriggerButtonTapEvent]: CustomEvent<{
            clientX: number;
            clientY: number;
        }>;
    }
}

declare global {
    interface HTMLElementEventMap {
        [triggerButtonGestureManagerTapEvent]: CustomEvent;
        [triggerButtonGestureManagerHoldStartEvent]: CustomEvent;
        [triggerButtonGestureManagerHoldEndEvent]: CustomEvent;
        swipeupstart: CustomEvent<Point>;
        swipeup: CustomEvent<Point>;
        swipeupend: CustomEvent<Point>;
        swiperightstart: CustomEvent<Point>;
        swiperight: CustomEvent<Point>;
        swiperightend: CustomEvent<Point>;
        swipedownstart: CustomEvent<Point>;
        swipedown: CustomEvent<Point>;
        swipedownend: CustomEvent<Point>;
        swipeleftstart: CustomEvent<Point>;
        swipeleft: CustomEvent<Point>;
        swipeleftend: CustomEvent<Point>;
    }
}

interface SparkScanViewIconMap {
    scanner(): string;
    expand(): string;
    shrink(): string;
    aimer(): string;
    torchOff(): string;
    torchOn(): string;
    handle(): string;
    continuous(): string;
    soundOff(): string;
    soundOn(): string;
    hapticOff(): string;
    hapticOn(): string;
    hand(): string;
}
declare class SparkScanViewIcon extends HTMLElement {
    private static readonly observedAttributes;
    private readonly icons;
    get icon(): keyof SparkScanViewIconMap;
    set icon(icon: keyof SparkScanViewIconMap);
    get fill(): string;
    set fill(fill: string);
    get size(): number;
    set size(size: number);
    get [inlineStyleAttribute](): string | null;
    set [inlineStyleAttribute](inlineStyle: string | null);
    static create(): SparkScanViewIcon;
    private render;
    private aspectRatioForViewbox;
    private heightForViewbox;
    private connectedCallback;
    private attributeChangedCallback;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewIconTag]: SparkScanViewIcon;
    }
}

type SparkScanViewToastType = "error" | "info" | "warning";
declare class SparkScanViewToast extends HTMLElement {
    private static readonly observedAttributes;
    private timeout?;
    get type(): SparkScanViewToastType;
    set type(type: SparkScanViewToastType);
    get message(): string;
    set message(message: string);
    private get visible();
    private set visible(value);
    static create(): SparkScanViewToast;
    show(type: SparkScanViewToastType, message: string, duration: number): void;
    hide(): void;
    private render;
    private connectedCallback;
    private disconnectedCallback;
    private attributeChangedCallback;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewToastTag]: SparkScanViewToast;
    }
}

declare enum SparkScanViewMiniPreviewButtonType {
    ResizeButton = "resizeButton",
    ZoomButton = "zoomButton"
}
declare class SparkScanViewMiniPreview extends HTMLElement {
    static observedAttributes: (keyof SparkScanViewMiniPreview)[];
    host: HTMLElement;
    private toast;
    private resizeButton?;
    private resizeButtonIcon?;
    private zoomButton?;
    private overlay;
    private swiping;
    private resizeButtonTapListener;
    private zoomButtonTapListener;
    private pointerDownListener;
    private pointerMoveListener;
    private pointerUpListener;
    private fadeOutAnimation;
    private replayFadeOutTimeout;
    private viewportFitCoverEnabled;
    private previousPointerEvent?;
    get visible(): boolean;
    set visible(visible: boolean);
    get expanded(): boolean;
    set expanded(expanded: boolean);
    get [zoomFactorAttribute](): number;
    set [zoomFactorAttribute](zoomFactor: number);
    get darkened(): boolean;
    set darkened(darkened: boolean);
    get orientation(): OrientationType;
    set orientation(orientation: OrientationType);
    get [previewSizeControlVisibleAttribute](): boolean;
    set [previewSizeControlVisibleAttribute](previewSizeControlVisible: boolean);
    get [zoomSwitchControlVisibleAttribute](): boolean;
    set [zoomSwitchControlVisibleAttribute](zoomSwitchControlVisible: boolean);
    static create(): SparkScanViewMiniPreview;
    showToast(type: SparkScanViewToastType, message: string, duration: number): void;
    hideToast(): void;
    zoomIn(): void;
    zoomOut(): void;
    fadeOut(): Promise<boolean>;
    cancelFadeOut(): void;
    rewindAnimation(): Promise<void>;
    private render;
    private onResizeButtonTap;
    private onZoomButtonTap;
    private onPointerDown;
    private onPointerMove;
    private onPointerUp;
    private getViewportFitCoverEnabled;
    private connectedCallback;
    private disconnectedCallback;
    private attributeChangedCallback;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewMiniPreviewTag]: SparkScanViewMiniPreview;
    }
    interface HTMLElementEventMap {
        [miniPreviewButtonTapEvent]: CustomEvent<{
            tapped: SparkScanViewMiniPreviewButtonType.ResizeButton;
            expanded: boolean;
        } | {
            tapped: SparkScanViewMiniPreviewButtonType.ZoomButton;
            zoomFactor: number;
        }>;
        [miniPreviewSwipeUpEvent]: CustomEvent;
        [miniPreviewSwipeDownEvent]: CustomEvent;
    }
}

declare global {
    interface HTMLElementEventMap {
        [orientationChangeEvent]: CustomEvent<OrientationType>;
    }
}

declare class SparkScanViewTriggerButton extends HTMLElement {
    sidebar?: SparkScanViewSidebar | null;
    expandedTriggerButton: SparkScanViewExpandedTriggerButton;
    collapsedTriggerButton: SparkScanViewCollapsedTriggerButton;
    private styleElement;
    get expanded(): boolean;
    set expanded(expanded: boolean);
    get rounded(): boolean;
    set rounded(rounded: boolean);
    get [leftHandModeAttribute](): boolean;
    set [leftHandModeAttribute](leftHandMode: boolean);
    get message(): string;
    set message(message: string);
    static create(): SparkScanViewTriggerButton;
    connectedCallback(): void;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewTriggerButtonTag]: SparkScanViewTriggerButton;
    }
}

declare class SparkScanViewVisualFeedback extends HTMLElement {
    private styleElement;
    get success(): boolean;
    set success(success: boolean);
    get error(): boolean;
    set error(error: boolean);
    static create(): SparkScanViewVisualFeedback;
    fadeIn(opacity: string, duration: number): Promise<void>;
    fadeOut(opacity: string, duration: number): Promise<void>;
    emitSuccessFeedback(): Promise<void>;
    emitErrorFeedback(): Promise<void>;
    connectedCallback(): void;
}
declare global {
    interface HTMLElementTagNameMap {
        [sparkScanViewVisualFeedbackTag]: SparkScanViewVisualFeedback;
    }
}

export { SparkScan as S, SparkScanListener as a, SparkScanPreviewBehavior as b, SparkScanScanningBehavior as c, SparkScanScanningMode as d, SparkScanScanningModeDefault as e, SparkScanScanningModeTarget as f, SparkScanSession as g, SparkScanSessionJSON as h, SparkScanSettings as i, SparkScanSettingsJSON as j, SparkScanToastSettings as k, SparkScanView as l, SparkScanViewErrorFeedback as m, SparkScanViewSettings as n, SparkScanViewSuccessFeedback as o, SparkScanFeedbackDelegate as p, SparkScanBarcodeErrorFeedback as q, SparkScanBarcodeFeedback as r, SparkScanBarcodeSuccessFeedback as s };
